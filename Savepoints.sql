set search_path to tests;

-- PREPARAMOS UN PAR DE TABLAS PARA LA PRUEBA DE TRANSACCIONES Y SAVEPOINTS
create table forsavepoints (
	id integer primary key,
	data varchar
);

create table savepointslogs
(
	id serial primary key,
	problem varchar,
	datelog timestamptz
);

--DEMOSTRACION BASICA ANULANDO LAS 2 ULTIMAS SENTENCIAS DE INSERT Y SUS RESPECTIVOS LOGS
BEGIN;	
	INSERT INTO forsavepoints VALUES (1, 'dato1');
	INSERT INTO savepointslogs VALUES (DEFAULT, 'INSERT 1 WITH SUCCESS', current_timestamp);
	SAVEPOINT my_savepoint1;

	INSERT INTO forsavepoints VALUES (2, 'dato2');
	INSERT INTO savepointslogs VALUES (DEFAULT, 'INSERT 2 WITH SUCCESS', current_timestamp);

	INSERT INTO forsavepoints VALUES (3, 'dato3');
	INSERT INTO savepointslogs VALUES (DEFAULT, 'INSERT 3 WITH SUCCESS', current_timestamp);

	ROLLBACK TO SAVEPOINT my_savepoint1;
	RELEASE SAVEPOINT my_savepoint1;
END;

-- VAMOS A POR UN EJEMPLO DE USO MAS FUNCIONAL

-- PARTIMOS DE 2 LIMITACIONES IMPORTANTES:
-- * LAS FUNCIONES NO PUEDEN EJECUTAR UN  ROLLBACK TO SAVEPOINT
-- * EN UNA TRANSACCION EJECUTADA PASO A PASO NO PODEMOS ACCEDER A VARIABLES COMO "NOT FOUNT", "UNIQUE VIOLATION"...

-- PARA CONOCER LOS VALORES DE LOS ERRORES ESTANDARD DE POSTGRESQL:
-- https://www.postgresql.org/docs/current/static/errcodes-appendix.html


-- PODEMOS ENCAPSULAR ALGUNAS ACCIONES EN FUNCIONES QUE NO RETORNARAN UN CODIGO 
-- POR EJEMPLO SI EL CODIGO ES UN CERO IMPLICA QUE NO HAN TENIDO EXITO
-- USAREMOS ESE CODIGO PARA SABER SI DENTRO DE LA TRANSACCION DEBEMOS HACER UN ROLLBACK TO SAVEPOINT
-- PERO CONTINUAMOS CON EL PROBLEMA DE TENER QUE TOMAR ESA DECISION "PRESENCIALMENTE"

--FUNCION PARA INSERTAR
CREATE OR REPLACE FUNCTION insert_forsavepoints(id integer) RETURNS int AS $$
BEGIN
	INSERT INTO forsavepoints VALUES ($1, 'dato'||$1);
	RETURN 1;
	EXCEPTION WHEN unique_violation THEN RETURN 0;
END;
$$ LANGUAGE plpgsql;

--FUNCION PARA ACTUALIZAR
CREATE OR REPLACE FUNCTION update_forsavepoints(id integer, newid integer) RETURNS int AS $$
BEGIN
	UPDATE forsavepoints SET id = $2  where id = $1;
	IF not found 
		then return 0;
		else RETURN 1;
	end if;
END;
$$ LANGUAGE plpgsql;



-- PODEMOS CREAR UN SCRIPT BASE O BIEN IR GENERANDO LAS INSTRUCCIONES ESTABLECIENDO SAVEPOINTS ESTRATEGICAMENTE
--TODAS LAS INSTRUCCIONES SERAN EJECUTADAS LINEA A LINEA OPTANDO POR HACER ROLLBACK O NO EN FUNCION
--DE LOS RESULTADOS QUE OBTENEMOS (PROBADLO DESDE CONSOLA EJECUTANDO COMANDO A COMANDO PORQUE PGADMIN NO SOPORTA ESTA FUNCIONALIDAD)

-- PARA ESTE EJEMPLO FORZAMOS UN ERROR EN EL SEGUNDO INSERT Y EN EL UPDATE PARA MOSTRAR COMO FUNCIONAN LOS SAVEPOINTS: 
-- LOS INSERTS 2 Y 5 SE REALIZARAN, DESHACIENDOSE EL INSERT 3 POR EL FALLO DEL INSERT1, Y EL INSERT 4 POR EL UPDATE
BEGIN;
	SELECT insert_forsavepoints (2);
	-- SI HA RETORNADO UN CERO EJECUTAR
	ROLLBACK;		-- SI YA NO FUNCIONA LA PRIMERA ACCION ABORTAMOS COMPLETAMENTE
	
	-- SI HA RETORNADO UN 1 EJECUTAR EL SIGUIENTE COMANDO PARA DEJAR UN LOG DE LA ACCION ANTERIOR
	INSERT INTO savepointslogs VALUES (DEFAULT, 'INSERT 2 WITH SUCCESS', current_timestamp);
	SAVEPOINT my_savepoint1;	-- MARCO PRIMER SAVEPOINT

	SELECT insert_forsavepoints (3);
	-- SI HA RETORNADO UN 1 EJECUTAR EL COMANDO DE CREACION DE LOG Y MARCAR UN NUEVO SAVEPOINT
	INSERT INTO savepointslogs VALUES (DEFAULT, 'INSERT 3 WITH SUCCESS', current_timestamp);
	SAVEPOINT my_savepoint2;	--SEGUNDO SAVEPOINT

	SELECT insert_forsavepoints (1);  --CON EL CODIGO DE EJEMPLO INICIAL YA EXISTIRIA EL VALOR 1
	-- SI HA RETORNADO UN CERO EJECUTAR
	ROLLBACK TO SAVEPOINT my_savepoint1;	-- ANULA EL INSERT3 DE HABERSE REALIZADO CORRECTAMENTE Y VUELVE
	
	-- SI HA RETORNADO UN 1 EJECUTAR LA INSTRUCCION PARA DEJAR UN LOG
	INSERT INTO savepointslogs VALUES (DEFAULT, 'INSERT 1 WITH SUCCESS', current_timestamp);
	SAVEPOINT my_savepoint3;	-- TERCER SAVEPOINT

	SELECT insert_forsavepoints (4);
	-- SI HA RETORNADO UN CERO EJECUTAR
	ROLLBACK TO SAVEPOINT my_savepoint1;	-- ANULA EL INSERT3 Y 1 SI HUBIERAN TENIDO EXITO Y VUELVE
	-- SI HA RETORNADO UN 1 EJECUTAR	
	INSERT INTO savepointslogs VALUES (DEFAULT, 'INSERT 4 WITH SUCCESS', current_timestamp);

	SELECT update_forsavepoints(10, 5);
	-- SI HA RETORNADO UN CERO EJECUTAR
	ROLLBACK TO SAVEPOINT my_savepoint3;	-- ANULA EL INSERT4
	-- SI HA RETORNADO UN 1 EJECUTAR EL COMANDO QUE REGISTRA EL LOG	
	INSERT INTO savepointslogs VALUES (DEFAULT, 'UPDATE 10 TO 5 WITH SUCCESS', current_timestamp);

	SELECT insert_forsavepoints (5);
	-- SI HA RETORNADO UN CERO EJECUTAR	
	ROLLBACK TO SAVEPOINT my_savepoint3;	-- ANULA EL INSERT4 Y EL UPDATE SI HUBIERA TENIDO EXITO Y VUELVE
	-- SI HA RETORNADO UN 1 EJECUTAR  EL COMANDO QUE REGISTRA EL LOG		
	INSERT INTO savepointslogs VALUES (DEFAULT, 'INSERT 5 WITH SUCCESS', current_timestamp);

	RELEASE SAVEPOINT my_savepoint1;	-- LIBERAMOS LOS SAVEPOINT PARA PODERLOS UTILIZAR EN OTRA TRANSACCION
	RELEASE SAVEPOINT my_savepoint2;
	RELEASE SAVEPOINT my_savepoint3;
END;


-- CONCLUSION: EL USO DE SAVEPOINTS ESTA RESTRINGIDO A UN CONTROL PRESENCIAL DURANTE LA EJECUCION DE LOS
--PROCESOS DE LA TRANSACCION, SE PUEDEN IR "IMPROVISANDO" DURANTE UN CONJUNTO DE ACCIONES O TENERLOS 
-- PREVISTOS COMO EN EL EJEMPLO ANTERIOR

-- PARA COMPROBAR FUNCIONALIDAD		
select * from forsavepoints;
truncate forsavepoints restart identity;
select * from savepointslogs
truncate savepointslogs restart identity;